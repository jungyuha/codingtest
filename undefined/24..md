# 24. \[최단거리] 벨만포드

(1) 벨만포드

참고 :[https://yabmoons.tistory.com/365](https://yabmoons.tistory.com/365)

* 음수가중치가 있는 그래프에서 사용하는 최단거리 알고리즘이다.
* 다익스트라와 마찬가지로 **한 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘이다.**
  * 다익스트라 알고리즘과는 달리 그리디 하지 않게 동작한다.
  * **다익스트라 알고리즘**은 "지금 당장 눈앞에 보이는, 연결되어 있는 정점들 중에서 **최소비용으로 연결된 정점을 선택**" 하는 방식이다.
  * **벨만포드 알고리즘**은 **그리디 하지 않고, 모든 경우의 수를 탐색**한다.
* 시간복잡도는 O(VE)이다.
* '모든 경우의 수를 다 탐색해 가면서 최소비용'을 찾는다.
* **음의 사이클을 발견하고 이에대해 최소비용을 제대로 계산할 수 없다.** 라고 알 수 있게 만들어주는 알고리즘이다.
*   음의 가중치가 있는 벨만 포드의 경우 다익스트라처럼 우선순위 큐를 사용할 경우

    최단 경로를 갱신하는 경우 우선선위 큐에 push하고 큐가 모두 빌 때까지 반복하므로 아래 그림과 같이 1에서 4까지의 경로가 2-3-4를 순환하면서 최단경로가  -1씩 무한히 갱신될 수 있다.

    * 따라서 정점의 수 N에 대하여 간선의 수는 최대 N(N-1)이므로 모든 정점에 대하여 N-1번 반복하면 모두 갱신할 수 있게 된다.
    * 따라서 N번째 반복에서 최단 경로가 또 한 번 갱신된다면 이는 무한히 갱신되는 경우가 된다.

#### 음의 싸이클 발생을 발견하는 방법

*   _음의 사이클이 없고 정점이 V개인 그래프에서,_

    _한 정점에서 출발한 다른 정점까지의 최단경로는 많아봐야 V-1개의 간선을 지난다._
* 따라서, 모든 정점에 대해 V-1번의 반복을 통해 가능한 모든 경로를 탐색한다.
*   정상적인 그래프라면(=**음의 사이클이 발생하지 않는** 그래프)

    **N - 1번을 탐색한 이후에, 또 한번의 탐색을 더 하더라도 절대로 ! 최소비용이 변하는 정점이 발생하지 않는다.**
* _**따라서 ,N - 1번 모든 간선을 탐색 후, 한번 더 모든 간선을 탐색을 진행하면 된다.**_
* 음의 사이클'을 가진 그래프였다면, 이 '**한번 더 탐색'**하는 과정에서 최소비용이 변하는 정점이 있을 것이다.

## 2) 벨만포드 알고리즘의 동작 과정

<figure><img src="../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

#### 동작원리

1\. **모든 간선들을 탐색**하면서, 간선이 잇는 출발정점이 '한번이라도 계산 된 정점'

![](<../.gitbook/assets/image (1) (1) (1) (1) (1).png>)

(즉 , 최단거리가 갱신된 정점)이라면 해당 간선이 잇는 정점의 거리를 비교해서 업데이트 한다. (이는 다익스트라오 동일한듯)

2\. 1번 과정을 모든 간선들이 모든 정점들을 최단거리로 이을 수 있을때까지 반복한다.

#### 코드

1.  처음에 최단 거리 배열을 무한대 값으로 갱신한다.

    ```cpp
    long long n ,m,dist[1004], INF = 987654321;

    cin >> n >> m; 
    fill(dist, dist + n + 1, INF); 
    dist[0] = 0;
    ```
2.  간선 정보를 저장한다.

    ```cpp
    vector<pair<int,int>> adj[1004]; 
            for(int i = 0; i < m; i++){
                cin >> a >> b >> c; 
                // a : 출발점 , b : 도착점 , c : 가중치
                adj[a - 1].push_back({b - 1, c}); 
            }
    ```
3.  모든 간선을 탐색한다.

    <pre class="language-cpp"><code class="lang-cpp">for(int i = 0; i &#x3C; n; i++){ // 모든 간선을 n번 탐색
        for(int here = 0; here &#x3C; n; here++){// 모든 간선 탐색
             for(auto there : adj[here]){
                 int d  = there.second; 
                 int to = there.first; 
                 if(dist[here] != INF &#x26;&#x26; dist[here] + d &#x3C; dist[to]){
                    if(i == n - 1)q.push(to); // 마지막 탐색
                       dist[to] = dist[here] + d; 
                 } 
            } 
        }
    <strong>}
    </strong>
    </code></pre>

    마지막 탐색 때에도 갱신되면 **음의 싸이클**인것이다.
4. 참고
   * [https://8iggy.tistory.com/153](https://8iggy.tistory.com/153)

\
\

# 16118(달빛 여우)

#### **first Registered : 2023-3-19**

#### last modified : **2023-3-19**

## \[1] 이론

### (1) 최단 경로 구하기

### (2) 경로 비용 동적 계산

## \[2] 코드

```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 987654321;
int n,m,mp[4010][4010],res1[4010],res2[4010];
vector<int> adj[4010];
void init(){
    cin >> n >> m;
    int a,b,d;
    fill(res1,res1+4010,INF);fill(res2,res2+4010,INF);
    res1[1]=0; res2[1]=0;
    for(int i=0;i<m;i++){
        cin >> a >> b >> d;
        mp[a][b]=d;
        adj[a].push_back(b);
    }
}
void make_map_fox(){
    queue<int> q1;
    q1.push(1);
    int st=1;
    while(!q1.empty()){
        int cur = q1.front();q1.pop();
        for(int el : adj[cur]){
            int to = el;
            if(res1[cur]+mp[cur][to]<res1[to]){
                res1[to] = res1[cur]+mp[cur][to];
                q1.push(to);
            }
        }
    }
    for(int i=1;i<=n;i++){
        cout << res1[i] << " ";
    }
    cout << endl;
}
void make_map_wolf(){
    queue<pair<int,int>> q2;
    q2.push({1,-1});
    while(!q2.empty()){
        int cur = q2.front().first; int cur_val= q2.front().second;q2.pop();
            for(int el : adj[cur]){
                int to = el;
                 cout <<"to:"<<to<<","<< res2[cur] <<","<<pow(2,cur_val)<<","<<mp[cur][to]<<","<<res2[to]<<endl;
                if(res2[cur]+(pow(2,cur_val)*mp[cur][to])<res2[to]){
                    res2[to] = res2[cur]+(pow(2,cur_val)*mp[cur][to]);
                    q2.push({to,(-1)*cur_val});
                }
        }
    }
    for(int i=1;i<=n;i++){
        cout << res2[i] << " ";
    }
    cout << endl;
}
int main(){
    init();
    make_map_wolf();
}
/*
5 6
1 2 3
1 3 2
2 3 2
2 4 4
3 5 4
4 5 3
*/
```

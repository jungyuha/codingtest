# 2618번(경찰차)

#### **first Registered : 2023-2-14**

#### last modified : **2023-06-17**

**풀이 링크 :** [**https://www.acmicpc.net/source/62184083**](https://www.acmicpc.net/source/62184083)

## \[1] 이론

### (1) DP

#### dp\[a]\[b]일 때

* dp의 상태값 => a는 경찰차1의 위치 , b는 경찰차2의 위치
* dp의 값 => 경찰차1이 a의 위치에 있고 경찰차2가 b의 위치에 있을 때의 최소값

#### 문제 dp 풀이

![](<../../.gitbook/assets/image (4).png>)

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

## \[2] 코드

#### 내 코드

```cpp
#include <bits/stdc++.h>
using namespace std;

int dp[1010][1010];
int px[1010],py[1010];
int n,w;

int d (int strt,int next){
    return abs(px[strt]-px[next])+abs(py[strt]-py[next]);
}
void init(){
    cin >> n >> w;
    int ax,by;
    px[0]=1;py[0]=1;px[1]=n;py[1]=n;
    for(int i=2;i<w+2;i++){
        cin >> ax >> by;
        px[i]=ax; py[i]=by;
    }
}

//go1(경찰차1의 위치 , 경찰차 2의 위치) go1(0,1) 
int go1(int a, int b){
    if(a == w+1 || b == w+1) return 0;
    if(dp[a][b]) return dp[a][b];

    int next = max(a,b)+1;
    dp[a][b] = min(go1(a,next)+d(b,next),go1(next,b)+d(a,next));
    //cout <<"dp["<<a<<"]["<<b<<"] : "<<dp[a][b] << endl;
    return dp[a][b];
}
void trace(){
    int a=0,b=1;
    int next;
    string res="";
    for(int i=0;i<w;i++){
        next = max(a,b)+1;
    // cout << "----------\n";
    // cout << "a : " << a <<", b : "<<b <<", next : "<< next << ",dp["<<a<<"]["<<next<<"] : "<<dp[a][next]+d(a,next)<<",dp["<<next<<"]["<<b<<"] : "<<dp[next][b]+d(b,next)<<endl;
    // cout << "----------\n";
        if(dp[next][b]+d(a,next)<dp[a][next]+d(b,next)){
            a= next;
            res = res+"1";
        }
        else{
            b = next;
            res = res+"2";
        }
    }
    for(char a : res){
        cout << a << endl;
    }
}
int main(){
    init();
    cout << go1(0,1) << endl;
    trace();
}
```

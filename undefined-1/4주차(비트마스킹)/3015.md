# 3015(오아시스 재결합)

#### **first Registered : 2022-12-12**

#### last modified : **2022-12-12**

## \[1] 이론

### (1) 시나리오

### &#x20;![](<../../.gitbook/assets/image (2).png>)

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

## \[2] 코드

#### 내 코드

```cpp
#include <bits/stdc++.h>
using namespace std;

int a,b,res;
vector<int> aLst;
int main(){
    cin >> a;
    for(int i=0;i<a;i++){
        cin >> b;
        aLst.push_back(b);
    }

    for(int i=0;i<a;i++){
        int cur = aLst[i],mid_max=-1;
        for(int j=i+1;j<a;j++){
            int next = aLst[j];
            if(mid_max==-1 || ( max(mid_max,next)==next)){
                res++;
                mid_max=next;
            }
            if(cur < next) {break;}
        }
    }

    cout << res << "\n";
    return 0;
}
```

#### 내 수도 코드

```cpp
/*
*) 입력
7
2
4
1
2
2
5
1

*) 메모리
vector<int> aLst; [2 4 1 2 2 5 1]

*) 시나리오
(리스트 순회) i=0;i<aLst.size();i++
    현재 인덱스 int cur = aLst[i];
    int mid_max = -1;
    (현재인덱스다으부터순회) j=i+1;j<aLst.size();j++
        (내 다음에 있는 애) int next = aLst[j];
        if 나랑 접근한 애 OR 여태 봐왔던 애들중에 제일 큰 애
            (마주볼 수 있다.) res++; 
            mid_max= next;
        if (근데 얘가 나보다 크면) cur < next :
            (이제 다음애들은 나를 못 보므로 나는 토스 ) break;
*/

```

#### 스택 이용 코드

```cpp
```

#### 스택 이용 수도 코드

```cpp
```


/*
입력
첫째 줄에 수식의 길이 N(1 ≤ N ≤ 19)가 주어진다. 둘째 줄에는 수식이 주어진다. 수식에 포함된 정수는 모두 0보다 크거나 같고, 9보다 작거나 같다. 문자열은 정수로 시작하고, 연산자와 정수가 번갈아가면서 나온다.
연산자는 +, -, * 중 하나이다. 여기서 *는 곱하기 연산을 나타내는 × 연산이다. 항상 올바른 수식만 주어지기 때문에, N은 홀수이다.
수식에 괄호를 추가하면, 괄호 안에 들어있는 식은 먼저 계산해야 한다. 단, 괄호 안에는 연산자가 하나만 들어 있어야 한다. 중첩된 괄호는 사용할 수 없다. 

출력
첫째 줄에 괄호를 적절히 추가해서 얻을 수 있는 결과의 최댓값을 출력한다. 정답은 231보다 작고, -231보다 크다.

예제 입력 1 
9
3+8*7-9*2
*/
/*

1.시나리오(1)
mp1={3,8,7,9,2}; 
vis={0,0,0,0,0};
vector <int> res1 ={};
max_ = -1
(3+8)*7-9*2 : 괄호 있음({3,8}) , index = 0 , vis={1,1,0,0,0}; , res = 136; 
    (3+8)*(7-9)*2 : 괄호 있음({3,8},{7,9}) , index = 0 + 2 , vis={1,1,1,1,0}; , res= -44
    (3+8)*7-9*2 : 괄호 없음({3,8}) , index = 0+2 , vis={1,1,0,0,0};, res = 136;
        (3+8)*7-(9*2) : 괄호 있음({3,8},{9,2}) ,  index = 0+2+1, vis={1,1,0,1,1};, res = 59;
        (3+8)*7-9*2 : 괄호 없음({3,8}),  index = 0+2+1, vis={1,1,0,0,0};, res = 136;
3+8*7-9*2 : 괄호 없음 , index = 0, vis={1,1,0,0,0};
    3+(8*7)-9*2 : 괄호 있음
        3+(8*7)-(9*2) : 괄호 있음
        3+(8*7)-9*2 : 괄호 없음
    3+8*7-9*2 : 괄호 없음
        3+8*(7-9)*2 : 괄호 있음
        3+8*7-9*2 : 괄호 없음
            3+8*7-(9*2) : 괄호 있음
            3+8*7-9*2 : 괄호 없음

1.시나리오(2)
3+8*7-9*2
mp1={3,8,7,9,2}; 
vis={0,0,0,0,0};
vector<int> index;
max_ = -1
(3+8) : 괄호 있음, index = {0,1}, vis={1,1,0,0,0}; , mid = 0,new =11 ; 
    (3+8)*(7-9) : 괄호 있음 , index = {2,3}, vis={1,1,1,1,0}; , new = -2 ,mid = 11 *(-2) = -22 ; 
        (3+8)*(7-9)*2 : 괄호 있음 , index = {4,X}, return ; 
        (3+8)*(7-9) : 괄호 없음 , index = {4}, vis={1,1,1,1,1}; , new = 2 ,mid = (-22)*2 = -44 ; 
    (3+8)*7 : 괄호 없음 , index = {2}, vis={1,1,1,0,0}; , new = 7 ,mid = 11 *(7) = 77 ; 
        (3+8)*7-(9*2) : 괄호 있음 , index = {3,4}, vis={1,1,1,1,1}; , new = 18 ,mid =  77 -18 = 59 ;
        (3+8)*7-9 : 괄호 없음 , index = {3}, vis={1,1,1,1,0}; , new = 9 ,mid =  77-9 = 68 ; 
            (3+8)*7-9 : 괄호 있음 , index = {4,X} return ; 
            (3+8)*7-9*2 : 괄호 없음 , index = {4}, vis={1,1,1,1,1}; , new = 2 ,mid =  68 * 2; 
3+8 : 괄호 없음 , index = 0, vis={1,0,0,0,0} ,mid =0 , new = 3;

1.시나리오(3)
mp1={3,8,7,9,2};
oper={'+','*','-','*'};

함수a1(1) , index =0 //d여기까지!!!!!!
3
    없 : 8 ,a1
        없 : 7 ,a11
            없 : 9 , a111
                없 : 2 , a1111
                있 : X , a1111
            있 : (9,2) ,a111
                없 : X , a1112
                있 : X , a1112
        있(1함수2) : (7,9) , a11
            없 : 2 , a112
            있 : X , a112
    있 : (8,7) , a1
        없 : 9 , a12
            없 : 2 , a121
            있 : X , a121
        있 : (9,2) , a12
            없 : X , a122
            있 : X , a122


2. 구현
mp1={3,8,7,9,2};
cc = {'+','*','-','*'}
max_ = -1

cal(int a, char b , int c){
    if(b == '-'){

    }
    else if(b=='+'){

    }
    else if(b=='*'){
        
    }
    else if(b=='/'){
        if(c==0){
            return 
        }
    }
}
(3+8) : 괄호 있음, index = {0,1}, vis={1,1,0,0,0}; , mid = 0,new =11 ,cc_index = -1=>0,res=11; 
    (3+8)*(7-9) : 괄호 있음 , index = {2,3}, vis={1,1,1,1,0}; , new = -2 ,mid = 11,res = 11 *(-2) = -22 , cc_index = 0; 
        (3+8)*(7-9)*2 : 괄호 있음 , index = {4,X}, return ; 
        (3+8)*(7-9)*2 : 괄호 없음 , index = {4}, vis={1,1,1,1,1}; , new = 2 ,mid = (-22),res = (-22)*2 = -44  , cc_index = 1; 
    (3+8)*7 : 괄호 없음 , index = {2}, vis={1,1,1,0,0}; , new = 7 ,mid = 11,res = 11 *(7) = 77 ; 
        (3+8)*7-(9*2) : 괄호 있음 , index = {3,4}, vis={1,1,1,1,1}; , new = 18 ,mid =  77,res =  77 -18 = 59 ;
        (3+8)*7-9 : 괄호 없음 , index = {3}, vis={1,1,1,1,0}; , new = 9 ,res =  77-9 = 68 ,mid =  77; 
            (3+8)*7-9 : 괄호 있음 , index = {4,X} return ; 
            (3+8)*7-9*2 : 괄호 없음 , index = {4}, vis={1,1,1,1,1}; , new = 2 ,res =  68 * 2,mid =  68; 
3 : 괄호 없음 , index = 0, vis={1,0,0,0,0} ,mid = 0 , new = 3,cc_index = -1 ,res = 3; 

mp1={3,8,7,9,2};
cc = {'+','*','-','*'}
max_ = -1
dfs(int start,int mid,int cc_index) => start : 0 , mid : 0 ,cc_index = -1 
    //if(mp1.size()==start) {max_ mid 비교; return;} 
    int new,res;
    char c; // 연산자
    
    // 1. 괄호 없음
    new = mp1[start] // 3
    if(cc_index > 0){ // 맨 앞이면 연산 안 함
        res = cal(mid,cc[cc_index],new);
    }
    else ={
        res = new;
    }
    
    dfs(start+1,res,cc_index+1); // index = 1 , res = 3, cc_index = 0
    
    // 2. 괄호 있음
    new = cal(mp1[start],cc[cc_index+1],mp1[start+1]);  // 11
     if(cc_index > 0){ // 맨 앞이면 연산 안 함
        res = cal(mid,cc[cc_index],new);
    }
    else ={
        res = new;
    }
    dfs(start+2,res,cc_index); // index = 2 , res = 11, cc_index = 1


*/ 

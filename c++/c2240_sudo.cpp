/*
*) 입력
자두는 T(1≤T≤1,000)초 동안 떨어지게 된다.
자두는 최대 W(1≤W≤30)번만 움직이고 싶어 한다.
매 초마다 어느 나무에서 자두가 떨어질지에 대한 정보가 주어졌을 때, 자두가 받을 수 있는 자두의 개수를 구해내는 프로그램을 작성하시오.
자두는 1번 자두나무 아래에 위치해 있다고 한다.

입력
첫째 줄에 두 정수 T, W가 주어진다. 다음 T개의 줄에는 각 순간에 자두가 떨어지는 나무의 번호가 1 또는 2로 주어진다

7 2
2
1
1
2
2
1
1

*) 메모리
//int mp[t][p][w]
int mp[1000][2][30],arr[1000];
*) 점화식 (t : 7 / w : 5)
(1) 1초 , 위치 : 1 mp[1][0][0] = 0 + (arr[1]-1 == 0 ? 1 : 0)
(2) 1초 , 위치 : 2 mp[1][1][1] = 0 + (arr[1]-1 == 1 ? 1 : 0)
(3) 2초 , 위치 : 1 mp[2][0][0] = (1) + (arr[2]-1 == 0 ? 1 : 0)
(?) 2초 , 위치 : 1 mp[2][0][2] = (1) + (arr[2]-1 == 0 ? 1 : 0)
(?) 2초 , 위치 : 2 mp[2][1][1] = (1) + (arr[2]-1 == 1 ? 1 : 0)
(?) 2초 , 위치 : 2 mp[2][1][1] = (2) + (arr[2]-1 == 1 ? 1 : 0)
  => mp[2][1][1] = max(((1) + (arr[2]-1 == 1 ? 1 : 0)),((2) + (arr[2]-1 == 1 ? 1 : 0)))
                 = max((mp[1][0][0] + (arr[2]-1 == 1 ? 1 : 0)),(mp[1][1][1] + (arr[2]-1 == 1 ? 1 : 0)))
                 = max(mp[1][0][0],mp[1][1][1])+(arr[2]-1 == 1 ? 1 : 0)

점화식  : mp[t][p][w] = max(mp[t-1][p][w],mp[t-1][~p][w-1])+(arr[t]-1 == p ? 1 : 0)
mp[1][0][0] = max(mp[0][0][0],mp[0][1][-1])+(arr[1]-1 == p ? 1 : 0)
mp[1][0][1] = max(mp[0][0][1],mp[0][1][0])+(arr[t]-1 == p ? 1 : 0)

*) 점화식 (t : 7 / w : 5)
mp[t][p][w] = max(mp[t-1][p][w],mp[t-1][~p][w-1])+(arr[t]-1 == p ? 1 : 0)

*) 시나리오
(메인)
go(0,)

int go(int n, int p , int w):
  if n==t :
    return 0;
  return +(arr[t]-1 == p ? 1 : 0)
  return (arr[t]-1 == p ? 1 : 0) 
  mp[t][p][w] = max(go(t-1,p,w),go(t-1,~p,w+1))+(arr[t]-1 == p ? 1 : 0);
  return max(go(t-1,p,w),go(t-1,~p,w+1))+(arr[t]-1 == p ? 1 : 0);
*) 출력

*/
# 14. 비트 마스킹

#### **first Registered : 2022-11-30**

#### last modified : **2022-11-30**

## \[1] 이진법

### 1)

![](broken-reference)

### 2) 이진수를 이용해 불리언배열을 표현

1. 4는 100
2. 2는 010
3. 1은 001
   1. 0번째 비트가 켜져있다.
4. 3은 011
   1. 0, 1번째 비트가 켜져있다.

## \[2] 비트 연산자

### 1) **왼쪽 시프트 연산자 << : 수를 왼쪽으로 이동한다는 의미**

1. 기초
   1. n = n & (111..) => n의 1인것들만 가져옴 , 나머지는 0
      * (111..)에서 특정자리의 수가 0일 경우 그 자리수는 n에서 꺼짐(0이됨)
2. **보통 (1 << x)이 꼴로 많이 쓰입니다.**
   * (1 << 2)는 2의 2승 : 4
   * (1 << 0)은 2의 0승 : 1

### 2) 비트 연산자 대표 공식

#### **1. idx번째 비트 끄기**

1. n = n & (111..) => n의 1인것들만 가져옴 , 나머지는 0
   * (111..)에서 특정자리의 수가 0일 경우 그 자리수는 n에서 꺼짐(0이됨)
2. **예시 : 0110의 idx(=1)번째 비트 끄기**
   1. 0110
   2. 0000 => 1111 = \~(1<\<idx)꼴
      1. 0010 (1<\<idx) => 1101 \~(1<\<idx)
   3. **0110 & 1101 =>0100**

#### 2.크기가 n인 집합의 모든 비트 켜기

1. 예시 : 크기가 4인 집합의 모든 비트가 켜져있는 경우
   * **1111 = 15= 16-1 = (1<\<n)-1**

#### **3. idx번째 비트 켜기**

1. n = n || \~(1<\<idx)

#### **4. idx번째에 비트 켜져있는지 확인**&#x20;

1. n & (1<\<idx)

#### **5. 비트 뒤집기**&#x20;

1. **식 : 15 & \~(1 <\<idx)**
2. 예시 : (1 << idx) = (1 << 0) = 0000...0001을 뒤집는 경우
   1. 그냥 \~(1 << idx) 하면 1111...1110이 됨 ..하지만 0000...1110을 만들어야함&#x20;
   2. **1111 = 15=0000..1111**&#x20;
   3. **0000..1111 & 1111...1110 =0000..1110**
3. &#x20;기타 공식 : \~n = -n+1

#### 6. 최하위 비트 찾기

1. 예시 : 0110의 최하위 비트 찾기 (01**'1'**0)
   1. n : 0000..0110 = 6
   2. \~n : 1111..1001
   3. \~n+1 :1111..1010



\
\
